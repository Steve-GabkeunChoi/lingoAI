<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>로컬 오디오 녹음기 + 서버 업로드/다운로드</title>
<style>
:root{
  --bg:#0f1115; --panel:#161a22; --card:#1b2130; --text:#e6e9ef;
  --muted:#9aa4b2; --accent:#6ea8fe; --accent2:#a58bff; --border:#263044;
}
*{box-sizing:border-box}
html,body{margin:0;padding:0;background:var(--bg);color:var(--text);
  font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
.topbar{position:sticky;top:0;z-index:10;display:flex;justify-content:space-between;align-items:center;
  padding:14px 22px;background:rgba(15,17,21,.8);backdrop-filter:blur(8px);border-bottom:1px solid var(--border)}
.topbar .brand{font-weight:700}
.container{width:min(980px,92vw);margin:24px auto 64px;display:grid;gap:20px}
.panel{background:var(--panel);border:1px solid var(--border);border-radius:16px;
  padding:18px 20px;box-shadow:0 8px 24px rgba(0,0,0,.25)}
.panel h2{margin:0 0 12px 0;font-size:18px}
.grid3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:12px}
.grid2{display:grid;grid-template-columns:1fr 1fr;gap:12px}
@media(max-width:900px){.grid3{grid-template-columns:1fr}.grid2{grid-template-columns:1fr}}
label{display:flex;flex-direction:column;gap:6px;font-size:14px}
select,input[type=text]{background:var(--card);color:var(--text);border:1px solid var(--border);
  border-radius:12px;padding:10px 12px;width:100%}
button{display:inline-block;background:linear-gradient(135deg,var(--accent),var(--accent2));
  color:#fff;border:0;padding:10px 14px;border-radius:12px;cursor:pointer;transition:transform .08s ease}
button:hover{transform:translateY(-1px)}
button.ghost{background:transparent;color:var(--text);border:1px solid var(--border)}
.actions{display:flex;gap:10px;flex-wrap:wrap;margin-top:6px}
.muted{color:var(--muted);font-size:13px;margin-top:8px}
audio{width:100%}
.meter{height:8px;border-radius:6px;background:#0c0f14;border:1px solid var(--border);overflow:hidden;margin-top:8px}
.meter>span{display:block;height:100%;width:0%;background:linear-gradient(90deg,#3bd671,#ffcf5a,#ff6b6b)}
.row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
.footer{width:min(980px,92vw);margin:18px auto 36px;color:var(--muted);text-align:center;
  border-top:1px solid var(--border);padding-top:12px;font-size:13px}
.badge{display:inline-block;padding:3px 8px;border-radius:999px;border:1px solid var(--border);background:var(--card);font-size:12px}
hr.sep{border:0;border-top:1px dashed var(--border);margin:12px 0}

/* 모달 */
.modal{position:fixed;inset:0;display:none}
.modal.show{display:grid;place-items:center}
.modal .overlay{position:absolute;inset:0;background:rgba(0,0,0,.45);backdrop-filter:blur(2px)}
.modal .sheet{position:relative;width:min(880px,92vw);background:var(--panel);border:1px solid var(--border);
  border-radius:16px;padding:16px;box-shadow:0 12px 36px rgba(0,0,0,.5);max-height:84vh;display:flex;flex-direction:column}
.modal .sheet h3{margin:0 0 10px 0}
.modal .sheet .toolbar{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:10px}
.modal .sheet .list{flex:1;overflow:auto;border:1px solid var(--border);border-radius:12px}
.modal .sheet ul{list-style:none;margin:0;padding:0}
.modal .sheet li{display:grid;grid-template-columns:1fr auto;gap:8px;align-items:center;
  padding:10px 12px;border-bottom:1px solid var(--border);background:var(--card)}
.modal .sheet li:hover{filter:brightness(1.06)}
.modal .sheet li:last-child{border-bottom:none}
.modal .sheet .meta{color:var(--muted);font-size:12px}
.modal .sheet .title{font-weight:600}
.modal .sheet .close{position:absolute;top:10px;right:10px}
</style>
</head>
<body>
<header class="topbar">
  <div class="brand">로컬 오디오 녹음기</div>
  <div class="meta badge" id="ctxBadge">context</div>
</header>

<main class="container">
  <!-- 서버 연결 -->
  <section class="panel">
    <h2>서버 연결</h2>
    <div class="grid3">
      <label>API Base
        <input id="apiBase" type="text" placeholder="예: https://api.example.com 또는 http://localhost:5000"/>
      </label>
      <label>엔드포인트
        <input id="apiPath" type="text" value="/upload_recording" />
      </label>
      <label style="align-self:end">
        <button id="applyApi">적용</button>
      </label>
    </div>
    <div class="muted">업로드 필드: audio, worker_id, tags, lat, lng, sample_rate, bit_depth, channels, format, duration_ms</div>
    <div id="apiInfo" class="muted" style="margin-top:6px"></div>
  </section>

  <!-- 장치/녹음 -->
  <section class="panel">
    <h2>장치 · 설정</h2>

    <div class="grid3">
      <label>입력 장치
        <select id="device"></select>
      </label>
      <label>포맷
        <select id="format">
          <option value="webm" selected>WebM/Opus(용량 작음)</option>
          <option value="wav">WAV(무손실)</option>
        </select>
      </label>
      <label>샘플레이트
        <select id="sampleRate">
          <option>16000</option>
          <option selected>44100</option>
          <option>48000</option>
        </select>
      </label>
      <label>비트수(WAV)
        <select id="bitDepth">
          <option value="16" selected>16</option>
          <option value="24">24</option>
          <option value="32">32</option>
        </select>
      </label>
      <label>채널
        <select id="channels">
          <option value="1" selected>모노</option>
          <option value="2">스테레오</option>
        </select>
      </label>
      <label>파일명 접두사
        <input id="prefix" type="text" placeholder="예: rec_"/>
      </label>
    </div>

    <hr class="sep"/>

    <div class="grid3">
      <label>작업자 ID
        <input id="worker" type="text" placeholder="예: alice"/>
      </label>
      <label>태그
        <input id="tags" type="text" placeholder="쉼표로 구분"/>
      </label>
      <label style="align-self:end">
        <button id="btnGeo" class="ghost">현재 위치</button>
      </label>
    </div>
    <div class="grid2">
      <label>위도
        <input id="lat" type="text" placeholder="자동 또는 직접 입력"/>
      </label>
      <label>경도
        <input id="lng" type="text" placeholder="자동 또는 직접 입력"/>
      </label>
    </div>

    <div class="actions">
      <button id="btnPerm">마이크 권한</button>
      <button id="btnStart">녹음 시작</button>
      <button id="btnPause" class="ghost" disabled>일시정지</button>
      <button id="btnResume" class="ghost" disabled>재개</button>
      <button id="btnStop" class="ghost" disabled>정지</button>
      <button id="btnSave" class="ghost" disabled>로컬 저장</button>
      <button id="btnUpload" class="ghost" disabled>서버 업로드</button>
      <button id="btnOpenDl" class="ghost">서버 파일 다운로드</button>
    </div>

    <div class="row" style="margin-top:6px">
      <div class="badge" id="dur">00:00.0</div>
      <div class="badge" id="info">-</div>
    </div>

    <div class="meter"><span id="meterBar"></span></div>
    <div class="muted" id="status">대기 중</div>

    <audio id="player" controls style="margin-top:10px;"></audio>
    <div id="uploadResult" class="muted"></div>
  </section>
</main>

<footer class="footer">
  마이크 권한은 https 또는 localhost에서만 허용된다. 정적 서버로 열 것.
</footer>

<!-- 다운로드 모달 -->
<div id="dlModal" class="modal" aria-hidden="true">
  <div class="overlay"></div>
  <div class="sheet" role="dialog" aria-modal="true" aria-labelledby="dlTitle">
    <button class="close ghost" id="dlClose">닫기</button>
    <h3 id="dlTitle">서버 파일 목록</h3>
    <div class="toolbar">
      <input id="dlWorker" type="text" placeholder="작업자 ID 필터"/>
      <button id="dlRefresh">새로고침</button>
    </div>
    <div class="list">
      <ul id="dlList"></ul>
    </div>
  </div>
</div>

<script>
const els = {
  apiBase: document.getElementById('apiBase'),
  apiPath: document.getElementById('apiPath'),
  applyApi: document.getElementById('applyApi'),
  apiInfo: document.getElementById('apiInfo'),

  worker: document.getElementById('worker'),
  tags: document.getElementById('tags'),
  lat: document.getElementById('lat'),
  lng: document.getElementById('lng'),
  btnGeo: document.getElementById('btnGeo'),

  device: document.getElementById('device'),
  fmt: document.getElementById('format'),
  rate: document.getElementById('sampleRate'),
  bits: document.getElementById('bitDepth'),
  chs: document.getElementById('channels'),
  prefix: document.getElementById('prefix'),
  btnPerm: document.getElementById('btnPerm'),
  btnStart: document.getElementById('btnStart'),
  btnPause: document.getElementById('btnPause'),
  btnResume: document.getElementById('btnResume'),
  btnStop: document.getElementById('btnStop'),
  btnSave: document.getElementById('btnSave'),
  btnUpload: document.getElementById('btnUpload'),
  btnOpenDl: document.getElementById('btnOpenDl'),
  status: document.getElementById('status'),
  player: document.getElementById('player'),
  meterBar: document.getElementById('meterBar'),
  dur: document.getElementById('dur'),
  info: document.getElementById('info'),
  ctxBadge: document.getElementById('ctxBadge'),
  uploadResult: document.getElementById('uploadResult'),

  dlModal: document.getElementById('dlModal'),
  dlClose: document.getElementById('dlClose'),
  dlList: document.getElementById('dlList'),
  dlWorker: document.getElementById('dlWorker'),
  dlRefresh: document.getElementById('dlRefresh'),
};

function secureCtxLabel(){
  const h = location.hostname;
  const ok = (location.protocol==='https:' || h==='localhost' || h==='127.0.0.1' || h==='[::1]');
  els.ctxBadge.textContent = ok ? 'secure context' : 'not secure (권한 차단될 수 있음)';
}
secureCtxLabel();

const savedBase = localStorage.getItem('apiBase') || '';
const savedPath = localStorage.getItem('apiPath') || '/upload_recording';
els.apiBase.value = savedBase;
els.apiPath.value = savedPath;
function showApiInfo(){
  const base = els.apiBase.value.trim();
  const path = els.apiPath.value.trim();
  els.apiInfo.textContent = base ? `POST ${base.replace(/\/+$/,'')}${path}` : '서버 미설정';
}
showApiInfo();
els.applyApi.addEventListener('click', ()=>{
  localStorage.setItem('apiBase', els.apiBase.value.trim());
  localStorage.setItem('apiPath', els.apiPath.value.trim());
  showApiInfo();
  log('서버 설정 적용');
});

function setDepthEnabled(){ els.bits.disabled = (els.fmt.value !== 'wav'); }
els.fmt.addEventListener('change', setDepthEnabled); setDepthEnabled();

let mediaStream=null, mediaRecorder=null, chunks=[];
let audioCtx=null, srcNode=null, analyser=null, procNode=null;
let wavBuffers=[]; let rafId=null, startedAt=0, elapsed=0;
let recordedBlob=null, recordedExt='webm';

function log(s){ els.status.textContent = s; }
function fmtDur(ms){
  const t=Math.max(0,Math.floor(ms)); const m = Math.floor(t/60000); const s = Math.floor((t%60000)/1000); const d = Math.floor((t%1000)/100);
  return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}.${d}`;
}
function fmtSize(n){
  if (n == null) return '-';
  if (n < 1024) return n + ' B';
  if (n < 1024*1024) return (n/1024).toFixed(1) + ' KB';
  return (n/1024/1024).toFixed(1) + ' MB';
}
function tick(){
  const now = performance.now();
  if (startedAt) elapsed += (now - startedAt), startedAt = now;
  els.dur.textContent = fmtDur(elapsed);
  if (analyser){
    const arr = new Uint8Array(analyser.fftSize); analyser.getByteTimeDomainData(arr);
    let peak=0; for(let i=0;i<arr.length;i++){ const v=(arr[i]-128)/128; const a=Math.abs(v); if(a>peak) peak=a; }
    els.meterBar.style.width = Math.min(100, Math.round(peak*130)) + '%';
  }
  rafId = requestAnimationFrame(tick);
}
function startMeter(){
  if(rafId) cancelAnimationFrame(rafId);
  startedAt = performance.now();
  rafId = requestAnimationFrame(tick);
}
function stopMeter(){
  if(rafId) cancelAnimationFrame(rafId);
  rafId = null; startedAt = 0;
  els.meterBar.style.width = '0%';
}

async function ensurePermission(){
  try{
    const devId = els.device.value || undefined;
    const ch = parseInt(els.chs.value,10);
    const stream = await navigator.mediaDevices.getUserMedia({
      audio: { deviceId: devId?{exact:devId}:undefined, channelCount: ch, noiseSuppression:true, echoCancellation:true }
    });
    stream.getTracks().forEach(t=>t.stop());
    await populateDevices();
    log('마이크 권한 확인 완료');
  }catch(err){ log('권한 실패: ' + err.message); }
}

async function populateDevices(){
  const devs = await navigator.mediaDevices.enumerateDevices();
  const inputs = devs.filter(d=>d.kind==='audioinput');
  els.device.innerHTML = '';
  inputs.forEach((d,i)=>{
    const op=document.createElement('option');
    op.value=d.deviceId; op.textContent = d.label || `마이크 ${i+1}`;
    els.device.appendChild(op);
  });
}

async function start(){
  try{
    recordedBlob=null; els.player.src=''; els.btnSave.disabled=true; els.btnUpload.disabled=true; els.uploadResult.textContent='';
    const fmt = els.fmt.value; const sr = parseInt(els.rate.value,10); const bits=parseInt(els.bits.value,10); const ch=parseInt(els.chs.value,10);
    const devId = els.device.value || undefined;

    mediaStream = await navigator.mediaDevices.getUserMedia({
      audio: { deviceId: devId?{exact:devId}:undefined, channelCount: ch, noiseSuppression:true, echoCancellation:true }
    });

    audioCtx = new (window.AudioContext||window.webkitAudioContext)({ sampleRate: sr });
    srcNode = audioCtx.createMediaStreamSource(mediaStream);
    analyser = audioCtx.createAnalyser(); analyser.fftSize = 2048;
    srcNode.connect(analyser);

    if (fmt === 'webm'){
      const mime = 'audio/webm;codecs=opus';
      if (!MediaRecorder || !MediaRecorder.isTypeSupported(mime)) throw new Error('이 브라우저는 audio/webm을 지원하지 않음');
      chunks=[]; mediaRecorder = new MediaRecorder(mediaStream,{ mimeType:mime, audioBitsPerSecond:128000 });
      mediaRecorder.ondataavailable = e=>{ if(e.data && e.data.size>0) chunks.push(e.data); };
      mediaRecorder.onstop = ()=>{
        recordedBlob = new Blob(chunks,{type:mime}); recordedExt='webm';
        els.player.src = URL.createObjectURL(recordedBlob);
        els.btnSave.disabled=false; els.btnUpload.disabled=false; cleanupAfterStop();
      };
      mediaRecorder.start();
      els.info.textContent = `format webm · rate ${sr} · ch ${ch}`; log('녹음 중(WebM/Opus)…');
    }else{
      const bufferSize=4096; procNode = audioCtx.createScriptProcessor(bufferSize, ch, ch);
      wavBuffers = [];
      procNode.onaudioprocess = e=>{
        const inBuf = e.inputBuffer;
        if (ch===1){
          const ch0 = inBuf.getChannelData(0);
          if (inBuf.numberOfChannels>1){
            const ch1=inBuf.getChannelData(1); const mono=new Float32Array(ch0.length);
            for(let i=0;i<mono.length;i++) mono[i]=(ch0[i]+ch1[i])*0.5;
            wavBuffers.push(mono);
          }else{ wavBuffers.push(new Float32Array(ch0)); }
        }else{
          const L = new Float32Array(inBuf.getChannelData(0));
          const R = new Float32Array((inBuf.numberOfChannels>1)?inBuf.getChannelData(1):inBuf.getChannelData(0));
          wavBuffers.push(L,R);
        }
      };
      srcNode.connect(procNode); procNode.connect(audioCtx.destination);
      els.info.textContent = `format wav · rate ${sr} · bits ${bits} · ch ${ch}`; log('녹음 중(WAV)…');
    }

    els.btnStart.disabled=true; els.btnStop.disabled=false; els.btnPause.disabled=false; els.btnResume.disabled=true;
    elapsed = 0; startMeter();
  }catch(err){ log('시작 실패: ' + err.message); cleanupAfterStop(true); }
}

function pause(){
  if (mediaRecorder && mediaRecorder.state==='recording') mediaRecorder.pause();
  if (audioCtx && audioCtx.state==='running') audioCtx.suspend();
  els.btnPause.disabled=true; els.btnResume.disabled=false; log('일시정지');
}
function resume(){
  if (mediaRecorder && mediaRecorder.state==='paused') mediaRecorder.resume();
  if (audioCtx && audioCtx.state==='suspended') audioCtx.resume();
  startedAt = performance.now(); els.btnPause.disabled=false; els.btnResume.disabled=true; log('재개');
}
function stop(){
  try{
    if (mediaRecorder){
      if (mediaRecorder.state!=='inactive') mediaRecorder.stop();
    }else{
      const sr=parseInt(els.rate.value,10), bits=parseInt(els.bits.value,10), ch=parseInt(els.chs.value,10);
      const wavBuffer = encodeWAV(wavBuffers, sr, bits, ch);
      recordedBlob = new Blob([wavBuffer], {type:'audio/wav'}); recordedExt='wav';
      els.player.src = URL.createObjectURL(recordedBlob);
      els.btnSave.disabled=false; els.btnUpload.disabled=false; cleanupAfterStop();
    }
    log('정지 중…');
  }catch(err){ log('정지 실패: ' + err.message); cleanupAfterStop(true); }
}
function cleanupAfterStop(immediate=false){
  try{
    if (procNode){ procNode.disconnect(); procNode=null; }
    if (srcNode){ try{ srcNode.disconnect(); }catch(_){}
      srcNode=null;
    }
    if (mediaStream){ mediaStream.getTracks().forEach(t=>t.stop()); mediaStream=null; }
    if (audioCtx){
      const close = ()=>audioCtx && audioCtx.close().catch(()=>{}); 
      if (immediate) close(); else setTimeout(close, 0);
      audioCtx=null; analyser=null;
    }
  }catch(_){}
  stopMeter();
  els.btnStart.disabled=false; els.btnStop.disabled=true; els.btnPause.disabled=true; els.btnResume.disabled=true;
  if (recordedBlob) log('정지 완료');
}

function saveFile(){
  if (!recordedBlob) return;
  const name = suggestName();
  if (window.showSaveFilePicker){
    (async()=>{
      try{
        const handle = await showSaveFilePicker({
          suggestedName: name,
          types: [{ description: recordedExt.toUpperCase(), accept: {[recordedBlob.type]: ['.'+recordedExt]} }]
        });
        const w = await handle.createWritable(); await w.write(recordedBlob); await w.close();
        log('파일 저장 완료');
      }catch(err){ if (err && err.name!=='AbortError') log('저장 실패: ' + err.message); }
    })();
  }else{
    const url = URL.createObjectURL(recordedBlob);
    const a = document.createElement('a'); a.href = url; a.download = name;
    document.body.appendChild(a); a.click(); a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 1500);
    log('파일 다운로드 시작');
  }
}
function suggestName(){
  const pad=n=>String(n).padStart(2,'0'); const d=new Date();
  const stamp=`${d.getFullYear()}${pad(d.getMonth()+1)}${pad(d.getDate())}_${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}`;
  return (els.prefix.value || 'rec_') + stamp + '.' + recordedExt;
}

async function uploadBlob(){
  if (!recordedBlob){ log('업로드할 녹음이 없습니다'); return; }
  const base = els.apiBase.value.trim(); const path = els.apiPath.value.trim() || '/upload_recording';
  if (!base){ log('API Base를 입력하세요'); return; }
  const url = base.replace(/\/+$/,'') + path;

  const fd = new FormData();
  const name = suggestName();
  fd.append('audio', recordedBlob, name);
  fd.append('worker_id', els.worker.value.trim() || 'unknown');
  fd.append('tags', els.tags.value.trim() || '');
  if (els.lat.value.trim()) fd.append('lat', els.lat.value.trim());
  if (els.lng.value.trim()) fd.append('lng', els.lng.value.trim());
  fd.append('sample_rate', els.rate.value);
  fd.append('bit_depth', els.bits.value);
  fd.append('channels', els.chs.value);
  fd.append('format', els.fmt.value);
  fd.append('duration_ms', String(Math.round(elapsed)));

  els.uploadResult.textContent = '업로드 중...';
  try{
    const res = await fetch(url, { method:'POST', body: fd });
    const txt = await res.text();
    let j = null; try { j = JSON.parse(txt); } catch(_){}
    if (!res.ok || (j && j.ok===false)){
      els.uploadResult.textContent = '업로드 실패: ' + (j?.error || res.status + ' ' + res.statusText);
      return;
    }
    if (j && j.ok){
      const dl = j.download ? (base.replace(/\/+$/,'') + j.download) : '';
      els.uploadResult.innerHTML = '업로드 완료'
        + (dl ? ` · <a href="${dl}" target="_blank" rel="noopener">서버에서 다운로드</a>` : '')
        + (j.filename ? ` · 파일명 ${j.filename}` : '');
      log('업로드 완료');
    }else{
      els.uploadResult.textContent = '업로드 완료(비JSON 응답): ' + txt.slice(0,200);
      log('업로드 완료');
    }
  }catch(err){
    els.uploadResult.textContent = '네트워크 오류: ' + err.message;
  }
}

// 서버 파일 다운로드 모달
function openDlModal(){
  const base = els.apiBase.value.trim();
  if (!base){ log('API Base를 먼저 입력하고 적용하세요'); return; }
  els.dlModal.classList.add('show');
  loadServerFiles();
}
function closeDlModal(){
  els.dlModal.classList.remove('show');
}
async function loadServerFiles(){
  const base = els.apiBase.value.trim().replace(/\/+$/,'');
  let url = base + '/records';
  const w = els.dlWorker.value.trim();
  if (w) url += '?worker_id=' + encodeURIComponent(w);
  els.dlList.innerHTML = `<li><div class="title">불러오는 중...</div></li>`;
  try{
    const res = await fetch(url);
    const j = await res.json();
    if (!j.ok){ els.dlList.innerHTML = `<li><div class="title">오류: ${j.error||res.status}</div></li>`; return; }
    if (!j.items.length){ els.dlList.innerHTML = `<li><div class="title">목록이 비었습니다</div></li>`; return; }
    els.dlList.innerHTML = '';
    j.items.forEach(it=>{
      const li = document.createElement('li');
      const created = it.created_at ? new Date(it.created_at).toLocaleString() : '-';
      li.innerHTML = `
        <div>
          <div class="title">${it.filename || '(파일명 없음)'}</div>
          <div class="meta">${created} · ${it.worker_id||'-'} · ${it.format||'-'} · ${it.sample_rate||'-'}Hz · ${it.bit_depth||'-'}bit · ch ${it.channels||'-'} · ${fmtSize(it.size)}</div>
        </div>
        <div>
          <a class="ghost" href="${base}/download/${it.id}" target="_blank" rel="noopener">다운로드</a>
        </div>
      `;
      li.addEventListener('click', (e)=>{
        // 행 클릭 시도 다운로드 링크 실행(버튼 클릭과 동일)
        if (e.target.tagName.toLowerCase() !== 'a'){
          window.open(`${base}/download/${it.id}`, '_blank', 'noopener');
        }
      });
      els.dlList.appendChild(li);
    });
  }catch(err){
    els.dlList.innerHTML = `<li><div class="title">네트워크 오류: ${err.message}</div></li>`;
  }
}

// 위치
els.btnGeo.addEventListener('click', ()=>{
  if(!navigator.geolocation){ log('위치 API 미지원'); return; }
  navigator.geolocation.getCurrentPosition(
    pos=>{ els.lat.value = pos.coords.latitude.toFixed(6); els.lng.value = pos.coords.longitude.toFixed(6); log('위치 설정 완료'); },
    err=>{ log('위치 실패: ' + (err.message||err.code)); },
    {enableHighAccuracy:true, timeout:5000}
  );
});

// 이벤트 바인딩
els.btnPerm.addEventListener('click', ensurePermission);
els.btnStart.addEventListener('click', start);
els.btnPause.addEventListener('click', pause);
els.btnResume.addEventListener('click', resume);
els.btnStop.addEventListener('click', stop);
els.btnSave.addEventListener('click', saveFile);
els.btnUpload.addEventListener('click', uploadBlob);

els.btnOpenDl.addEventListener('click', openDlModal);
els.dlClose.addEventListener('click', closeDlModal);
els.dlRefresh.addEventListener('click', loadServerFiles);
els.dlWorker.addEventListener('keydown', (e)=>{ if(e.key==='Enter') loadServerFiles(); });
els.dlModal.querySelector('.overlay').addEventListener('click', closeDlModal);

// 장치 목록
if (navigator.mediaDevices && navigator.mediaDevices.enumerateDevices){
  populateDevices().catch(()=>{});
} else {
  log('이 브라우저는 mediaDevices API를 지원하지 않습니다');
}

// WAV 인코딩
function encodeWAV(buffers, sampleRate, bitDepth, channels){
  if (!buffers.length) return new ArrayBuffer(44);
  const perCh = new Array(channels).fill(0).map(()=>[]);
  for(let i=0;i<buffers.length;i++) perCh[i%channels].push(buffers[i]);
  const merged = perCh.map(arr=>{
    const total = arr.reduce((a,b)=>a+b.length,0), out=new Float32Array(total);
    let off=0; arr.forEach(fr=>{ out.set(fr, off); off+=fr.length; }); return out;
  });
  const length=merged[0].length, inter=new Float32Array(length*channels);
  for(let i=0,idx=0;i<length;i++) for(let ch=0;ch<channels;ch++) inter[idx++]=merged[ch][i]||0;
  const bytesPerSample=(bitDepth===24)?3:(bitDepth/8), dataSize=inter.length*bytesPerSample;
  const buf=new ArrayBuffer(44+dataSize), view=new DataView(buf);
  function ws(o,s){ for(let i=0;i<s.length;i++) view.setUint8(o+i, s.charCodeAt(i)); }
  ws(0,'RIFF'); view.setUint32(4,36+dataSize,true); ws(8,'WAVE'); ws(12,'fmt ');
  view.setUint32(16,16,true); view.setUint16(20,1,true); view.setUint16(22,channels,true);
  view.setUint32(24,sampleRate,true); view.setUint32(28,sampleRate*channels*bytesPerSample,true);
  view.setUint16(32,channels*bytesPerSample,true); view.setUint16(34,bitDepth,true); ws(36,'data'); view.setUint32(40,dataSize,true);
  if (bitDepth===16){
    const out=new Int16Array(buf,44,inter.length);
    for(let i=0;i<inter.length;i++){ let s=Math.max(-1,Math.min(1,inter[i])); out[i]=s<0?s*0x8000:s*0x7FFF; }
  }else if (bitDepth===24){
    for(let i=0,off=44;i<inter.length;i++,off+=3){ let s=Math.max(-1,Math.min(1,inter[i])); let v=s<0?Math.floor(s*0x800000):Math.floor(s*0x7FFFFF);
      view.setUint8(off, v & 0xFF); view.setUint8(off+1, (v>>8) & 0xFF); view.setUint8(off+2, (v>>16) & 0xFF);
    }
  }else{
    const out=new Int32Array(buf,44,inter.length);
    for(let i=0;i<inter.length;i++){ let s=Math.max(-1,Math.min(1,inter[i])); out[i]=s<0?s*0x80000000:s*0x7FFFFFFF; }
  }
  return buf;
}
</script>
</body>
</html>
